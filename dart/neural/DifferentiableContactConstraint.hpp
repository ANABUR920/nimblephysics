#ifndef DART_NEURAL_DIFF_CONSTRAINT_HPP_
#define DART_NEURAL_DIFF_CONSTRAINT_HPP_

#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

#include <Eigen/Dense>

#include "dart/collision/Contact.hpp"
#include "dart/neural/NeuralConstants.hpp"
#include "dart/neural/NeuralUtils.hpp"
#include "dart/simulation/World.hpp"

namespace dart {

namespace constraint {
class ConstrainedGroup;
class ConstraintBase;
class ContactConstraint;
} // namespace constraint

namespace dynamics {
class Skeleton;
}

namespace simulation {
class World;
}

namespace neural {
class BackpropSnapshot;

enum SkeletonContactType
{
  UNSUPPORTED = 0,
  NONE = 1,
  VERTEX = 2,
  FACE = 3,
  EDGE = 4,
};

class DifferentiableContactConstraint
{

public:
  DifferentiableContactConstraint(
      std::shared_ptr<constraint::ConstraintBase> constraint, int index);

  Eigen::Vector3d getContactWorldPosition();

  /// This returns the normal of the contact, pointing from A to B. This IS NOT
  /// NECESSARILY THE DIRECTION OF FORCE! If this contact constraint is a
  /// friction constraint, then this returns the normal of the contact, and
  /// getContactWorldForceDirection() returns the direction of the force.
  Eigen::Vector3d getContactWorldNormal();

  Eigen::Vector3d getContactWorldForceDirection();

  /// This computes the force, in world space exponential coordinates, that this
  /// contact generates
  Eigen::Vector6d getWorldForce();

  /// This returns the nature of the contact, whether it's a face-vertex, or a
  /// vertex-face, or an edge-edge, or something else. This is relevant because
  /// we need to know in order to accurately estimate how the contact position
  /// and normal will change as we perturb skeletons by small amounts.
  collision::ContactType getContactType();

  /// This figures out what type of contact this skeleton is involved in.
  SkeletonContactType getSkeletonContactType(
      std::shared_ptr<dynamics::Skeleton> skel);

  /// This analytically computes a column of the A_c matrix just for this
  /// skeleton.
  Eigen::VectorXd getConstraintForces(std::shared_ptr<dynamics::Skeleton> skel);

  /// This analytically computes a column of the A_c matrix, for this contact
  /// constraint, across the whole world by concatenating the result for each
  /// skeleton together into a single vector.
  Eigen::VectorXd getConstraintForces(std::shared_ptr<simulation::World> world);

  /// Returns the gradient of the contact position with respect to the
  /// specified dof of this skeleton
  Eigen::Vector3d getContactPositionGradient(dynamics::DegreeOfFreedom* dof);

  /// Returns the gradient of the contact normal with respect to the
  /// specified dof of this skeleton
  Eigen::Vector3d getContactNormalGradient(dynamics::DegreeOfFreedom* dof);

  /// Returns the gradient of the contact force with respect to the
  /// specified dof of this skeleton
  Eigen::Vector3d getContactForceGradient(dynamics::DegreeOfFreedom* dof);

  /// Returns the gradient of the full 6d twist force
  Eigen::Vector6d getContactWorldForceGradient(dynamics::DegreeOfFreedom* dof);

  /// Returns the gradient of the screw axis with respect to the rotate dof
  Eigen::Vector6d getScrewAxisGradient(
      dynamics::DegreeOfFreedom* screwDof,
      dynamics::DegreeOfFreedom* rotateDof);

  /// This is the analytical Jacobian for the contact position
  math::LinearJacobian getContactPositionJacobian(
      std::shared_ptr<simulation::World> world);

  /// This is the analytical Jacobian for the contact normal
  math::LinearJacobian getContactForceDirectionJacobian(
      std::shared_ptr<simulation::World> world);

  /// This is the analytical Jacobian for the force (in exponential coordinates,
  /// in the world frame) generated by this contact. This is measuring how the
  /// force (in world space) changes as a result of moving the contact position
  /// and normal as a result of moving the joints of the skeletons in the world.
  math::Jacobian getContactForceJacobian(
      std::shared_ptr<simulation::World> world);

  /// This gets the constraint force for a given DOF
  double getConstraintForce(dynamics::DegreeOfFreedom* dof);

  /// This gets the gradient of constraint force at this joint with respect to
  /// another joint
  double getConstraintForceDerivative(
      dynamics::DegreeOfFreedom* dof, dynamics::DegreeOfFreedom* wrt);

  /// This returns an analytical Jacobian relating the skeletons that this
  /// contact touches.
  Eigen::MatrixXd getConstraintForcesJacobian(
      std::shared_ptr<simulation::World> world);

  /// This returns the skeletons that this contact constraint interacts with.
  const std::vector<std::shared_ptr<dynamics::Skeleton>>& getSkeletons();

  /////////////////////////////////////////////////////////////////////////////////////
  // Testing
  /////////////////////////////////////////////////////////////////////////////////////

  /// The linear Jacobian for the contact position
  math::LinearJacobian bruteForceContactPositionJacobian(
      std::shared_ptr<simulation::World> world);

  /// The linear Jacobian for the contact normal
  math::LinearJacobian bruteForceContactForceDirectionJacobian(
      std::shared_ptr<simulation::World> world);

  /// This is the brute force version of getWorldForceJacobian()
  math::Jacobian bruteForceContactForceJacobian(
      std::shared_ptr<simulation::World> world);

  /// This is the brute force version of getConstraintForcesJacobian()
  Eigen::MatrixXd bruteForceConstraintForcesJacobian(
      std::shared_ptr<simulation::World> world);

  /// Just for testing: This analytically estimates the way the contact position
  /// will change if we perturb the `dofIndex`'th DOF of `skel` by `eps`.
  Eigen::Vector3d estimatePerturbedContactPosition(
      std::shared_ptr<dynamics::Skeleton> skel, int dofIndex, double eps);

  /// Just for testing: This analytically estimates the way the contact normal
  /// will change if we perturb the `dofIndex`'th DOF of `skel` by `eps`.
  Eigen::Vector3d estimatePerturbedContactNormal(
      std::shared_ptr<dynamics::Skeleton> skel, int dofIndex, double eps);

  /// Just for testing: This analytically estimates the way the contact normal
  /// will change if we perturb the `dofIndex`'th DOF of `skel` by `eps`.
  Eigen::Vector3d estimatePerturbedContactForceDirection(
      std::shared_ptr<dynamics::Skeleton> skel, int dofIndex, double eps);

  /// Just for testing: This analytically estimates how a screw axis will move
  /// when rotated by another screw.
  Eigen::Vector6d estimatePerturbedScrewAxis(
      dynamics::DegreeOfFreedom* axis,
      dynamics::DegreeOfFreedom* rotate,
      double eps);

  /// Just for testing: This lets the world record what index this
  /// constraint is at, so that we can recover the analagous constraint from
  /// another forward pass for finite-differencing.
  void setOffsetIntoWorld(int offset, bool isUpperBoundConstraint);

  /// Just for testing: This runs a full timestep to get the way the contact
  /// position will change if we perturb the `dofIndex`'th DOF of `skel` by
  /// `eps`.
  Eigen::Vector3d bruteForcePerturbedContactPosition(
      std::shared_ptr<simulation::World> world,
      std::shared_ptr<dynamics::Skeleton> skel,
      int dofIndex,
      double eps);

  /// Just for testing: This runs a full timestep to get the way the contact
  /// normal will change if we perturb the `dofIndex`'th DOF of `skel` by
  /// `eps`.
  Eigen::Vector3d bruteForcePerturbedContactNormal(
      std::shared_ptr<simulation::World> world,
      std::shared_ptr<dynamics::Skeleton> skel,
      int dofIndex,
      double eps);

  /// Just for testing: This runs a full timestep to get the way the contact
  /// force direction will change if we perturb the `dofIndex`'th DOF of `skel`
  /// by `eps`.
  Eigen::Vector3d bruteForcePerturbedContactForceDirection(
      std::shared_ptr<simulation::World> world,
      std::shared_ptr<dynamics::Skeleton> skel,
      int dofIndex,
      double eps);

  /// Just for testing: This perturbs the world position of a skeleton to read a
  /// screw axis will move when rotated by another screw.
  Eigen::Vector6d bruteForceScrewAxis(
      dynamics::DegreeOfFreedom* axis,
      dynamics::DegreeOfFreedom* rotate,
      double eps);

  /// Return the index into the contact that this constraint represents. If it's
  /// >0, then this is a frictional constraint.
  int getIndexInConstraint();

  /// TODO: refactor this to move it to Skeleton
  /// This returns the axis for the specified dof index
  Eigen::Vector6d getWorldScrewAxis(
      std::shared_ptr<dynamics::Skeleton> skel, int dofIndex);

  /// TODO: refactor this to move it to Dof
  /// This returns the axis for the specified dof index
  Eigen::Vector6d getWorldScrewAxis(dynamics::DegreeOfFreedom* dof);

  /// This returns the constraint that's at our same location in the snapshot.
  /// This assumes that `mOffsetIntoWorld` and `mIsUpperBoundConstraint` are
  /// set.
  std::shared_ptr<DifferentiableContactConstraint> getPeerConstraint(
      std::shared_ptr<neural::BackpropSnapshot> snapshot);

protected:
  /// This returns 1.0 by default, 0.0 if this constraint doesn't effect the
  /// specified DOF, and -1.0 if the constraint effects this dof negatively.
  double getForceMultiple(dynamics::DegreeOfFreedom* dof);

protected:
  std::shared_ptr<constraint::ConstraintBase> mConstraint;
  std::shared_ptr<constraint::ContactConstraint> mContactConstraint;
  std::shared_ptr<collision::Contact> mContact;
  std::vector<std::string> mSkeletons;
  int mIndex;

  /// This allows us to locate this constraint in the world arrays. This value
  /// is not guaranteed to be set, but must be set before calling any of the
  /// brute force methods!
  int mOffsetIntoWorld;
  /// This allows us to locate this constraint in the world arrays. If true,
  /// we're in the upper bound array. Otherwise, we're clamping. This value
  /// is not guaranteed to be set, but must be set before calling any of the
  /// brute force methods!
  bool mIsUpperBoundConstraint;
};
} // namespace neural
} // namespace dart

#endif